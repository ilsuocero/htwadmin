This is a desktop app part of a wider project called "Hike the World" where there are 
involved three main components. 
1. Administration Site (htwadmin)
2. Server Side hosted on a remote Node.js where a Neo4j database is installed and managed by a Nodejs App
3. Client React Native App (Libre-HtW)

The scope of the project is to build a kind of Google Maps service for outdoors pathways. 
The path network is stored remotely in a Neo4j database and the Nodejs App which is managing it 
is responsible to mantain the database and to provide the path network to the React-native app
along with the navigation info to travel from one destination to another.

The app in this directory, named htwadmin,  is the administration App, which is responsible to create and mantain 
the Path Network. 

The htwadmin is incomplete, written a couple of years ago and needs an update and to be completed.

## SOCKET.IO CONNECTION ARCHITECTURE - LESSONS LEARNED

### ðŸŽ¯ **ARCHITECTURE OVERVIEW**

#### **Single Socket Instance Principle**
- **Only ONE socket instance** for the entire application
- **Centralized management** in Home.js component
- **Props-based distribution** to render components
- **Prevents connection chaos** and state confusion

#### **Component Structure**
```
Home.js â†’ useSocket() â† SINGLE instance!
  â†“
RenderPathNetwork â†’ props (socketOperations, isConnected)
RenderDestinations â†’ props (socketOperations, isConnected)  
RenderCrossRoads â†’ props (socketOperations, isConnected)
```

### ðŸ”§ **IMPLEMENTATION PATTERNS**

#### **1. Centralized Socket Hook (Home.js)**
```javascript
// Use the centralized socket hook - only when authenticated
const {
    socket,
    isConnected,
    isConnecting,
    error: socketError,
    socketOperations
} = useSocket(authenticated ? connectionState : null);
```

#### **2. Render Components (No useSocket Calls)**
```javascript
// âŒ WRONG - Creates multiple instances
const { socketOperations, isConnected } = useSocket(connectionState);

// âœ… CORRECT - Receives props from Home.js
function Component({ connectionState, socketOperations, isConnected }) {
```

#### **3. Socket Service (True Singleton)**
- Maintains single socket instance globally
- Handles reconnection and error recovery
- Manages authentication token updates

### ðŸ“¡ **EVENT NAMING CONVENTION**

#### **Current Event Names (English)**
- **Paths**: `listaSentieri` (request) / `printSentieri` (response)
- **Destinations**: `listaDestinazioni` (request) / `printDestinazioni` (response)
- **Crossroads**: `listCrossRoads` (request) / `printCrossRoads` (response)

#### **Consistency Rules**
- **Client and server MUST use same event names**
- **Use English names consistently**
- **Follow request/response pattern**: `listX` â†’ `printX`

### ðŸ” **DEBUGGING GUIDELINES**

#### **Rocket Logging Pattern**
```javascript
console.log('ðŸš€ Component-->[action]: description');
```

#### **Critical Debug Points**
1. **Authentication**: `HtWAppAuth-->[getIdToken]`
2. **Socket Creation**: `HtWSocketService-->[createSocket]`
3. **Connection State**: `HtWuseSocket-->[connect]`
4. **Component Flow**: `HtWRenderX-->[useEffect connectionState]`

#### **Common Issues & Solutions**

##### **Issue: isConnected stays false**
- **Cause**: Multiple socket instances competing
- **Solution**: Centralize socket management in Home.js

##### **Issue: No response from server**
- **Cause**: Event name mismatch between client/server
- **Solution**: Verify event names match exactly

##### **Issue: Connection state confusion**
- **Cause**: Components checking state before connection
- **Solution**: Use conditional rendering based on isConnected

### ðŸš€ **BEST PRACTICES**

#### **1. Connection State Flow**
```
AppAuth â†’ Authentication â†’ JWT Token
  â†“
Home.js â†’ useSocket(connectionState) â†’ Socket Service
  â†“
Render Components â†’ Props (socketOperations, isConnected)
  â†“
Data Loading â†’ Emit requests when isConnected === true
```

#### **2. Error Handling**
- Always check `isConnected` before emitting
- Handle `connect_error` events gracefully
- Implement automatic reconnection
- Provide user feedback for connection issues

#### **3. Performance**
- Single socket instance reduces resource usage
- Proper cleanup prevents memory leaks
- Conditional rendering avoids unnecessary operations

### ðŸ“‹ **FUTURE DEVELOPMENT**

#### **Adding New Socket Events**
1. **Update server** with new event names
2. **Create component** following props pattern
3. **Add to Home.js** props passing
4. **Test event flow** with rocket logging

#### **Maintenance Checklist**
- [ ] Verify single socket instance
- [ ] Check event name consistency
- [ ] Test connection state flow
- [ ] Validate error handling
- [ ] Monitor performance

### ðŸŽ¯ **KEY LESSONS LEARNED**

1. **Multiple socket instances cause connection chaos**
2. **Event name mismatches break communication**
3. **Centralized management ensures stability**
4. **Comprehensive logging is essential for debugging**
5. **Props-based architecture prevents state confusion**

